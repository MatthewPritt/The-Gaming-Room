# The-Gaming-Room

The Gaming Room was the client for this project, a company that wanted to expand its existing Android game, *Draw It or Lose It*, into a web-based, cross-platform application. The goal was to design software that could support multiple teams and players, ensure unique game and team names, and run reliably across different operating systems. The client required a scalable, secure system that could handle multiple concurrent users while maintaining game state and performance. The software design focused on using a server-based architecture with appropriate memory management and object control to meet these needs.

One aspect I did particularly well in developing the documentation was clearly outlining the system architecture and constraints. I was careful to explain design choices, such as using a singleton pattern to manage game instances and prevent duplicate games from being created. Working through the design document was especially helpful when developing the code because it forced me to think through potential issues—such as concurrency, data persistence, and platform compatibility—before writing any implementation. This planning reduced errors and made the coding process more structured and efficient.

If I could revise one part of my work, I would improve the evaluation of different operating platforms. While I compared options like Windows, Linux, and macOS, I could expand this section with more detailed performance metrics and cost considerations. This would strengthen the justification for the final recommendation and make the document more useful for stakeholders making deployment decisions. Overall, the design document could benefit from deeper technical comparisons supported by examples.

I interpreted the user’s needs by focusing on simplicity, reliability, and fairness in gameplay, ensuring that players had a smooth and consistent experience regardless of platform. Considering user needs is critical because software ultimately succeeds or fails based on how well it serves its users. In designing the software, I followed an object-oriented approach, breaking the system into manageable components and clearly defining responsibilities. In the future, I would continue using techniques such as UML diagrams, requirement analysis, and iterative design reviews to analyze and design similar software applications more effectively.
